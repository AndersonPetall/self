AOP(Aspect Oriented Programming)面向切面编程,一种编程范式,指导开发者如何组织程序结构
  OOP(Object Oriented Programming)面向对象编程
作用: 在不惊动原始设计的基础上为其进行功能增强
Spring理念: 无入侵式/侵无入式

AOP核心概念
  连接点(JoinPoint): 程序执行过程中的任意位置,粒度为执行方法,抛出异常,设置变量等
    在SpringAOP中,理解为方法的执行
  切入点(Pointcut): 匹配两节点的式子
    在SpringAOP中,一个切入点可以只描述一个具体的方法,也可以匹配多个方法
      一个具体方法: com.itheima.dao包下的BookDao接口中的无形参无返回值的save方法
      匹配多个方法: 所有save方法,所有get开头的方法,所有以Dao结尾的接口中的任意方法,所有带一个参数的方法
  通知(Advice): :在切入点处执行的操作,也就是共性功能
    在SpringAOP中,功能最终以方法的形式呈现
  通知类: 定义通知的类
  切面(Aspect): 描述通知与切入点的对应关系
  





AOP入门案例
接口与实现类的定义 
  public interface BookDao {
      public void save();
      public void update();
  }
  @Repository
  public class BookDaoImpl implements BookDao {
      public void save(){
          System.out.println(System.currentTimeMillis());
          System.out.println("book dao save out ... ");
      }
      public void update(){System.out.println("book dao update out ... ");}
  }
AOP注解驱动配置 config.SpringConfig文件
  @Configuration
  @ComponentScan("org.example")
  @EnableAspectJAutoProxy
  public class SpringConfig {}
绑定切入点与通知关系,指定通知添加到原始连接点具体执行位置 aop.MyAdvice文件
  @Component
  @Aspect
  public class MyAdvice {
      @Pointcut("execution(void org.example.dao.BookDao.update())")
      private void pt(){}
      @Before("pt(){}")  //当前函数前运行
      public void method(){System.out.println(System.currentTimeMillis());}}




AOP工作流程  (本质:代理模式)
  1.0 Spring容器启动
  2.0 读取所有切面配置中的切入点
  3.0 初始化bean,判定bean对应的类中的方法是否匹配到任意切入点
    匹配失败,创建对象    bd.getClass()  ==>  class org.example.dao.impl.BookDaoImpl
    匹配成功,创建原始对象(目标对象)的代理对象   bd.getClass()  ==>  class jdk.proxy2.$Proxy18
      目标对象(Target): 原始功能去掉共性功能对应的类产生的对象,这种对象是无法直接完成最终工作的
      代理(Proxy): 目标对象无法直接完成工作,需要对其进行功能回填,通过原始对象的代理对象实现
  4.0 获取bean执行方法
    获取bean, 调用方法并且执行,完成操作
    获取bean时代理对象时,根据代理对象的运行模式运行原始方法与增强的内容,完成操作





AOP切入点表达式
  切入点: 要进行增强的方法
  切入点表达式: 要进行增强的方法的描述方式

代码: 
public interface BookDao {public void update();}
@Repository
public class BookDaoImpl implements BookDao {public void update(){System.out.println("book dao update out ... ");}}

描述方式1.0: 执行org.example.dao包下的BookDao接口中的无参数update方法
  execution(void org.example.dao.BookDao.update())
描述方式2.0: 执行org.example.dao.impl包下的BookDaoImpl类中的无参update方法
  execution(void org.example.dao.impl.BookDaoImpl.update())
  
切入点表达式标准格式: 动作关键词(访问修饰符 返回值 包名.类/接口名.方法名(参数)异常名)
  execution(public void org.example.dao.impl.BookDaoImpl.update())
    动作关键词: 描述切入点的行为动作,例如execution表示执行到指定切入点
    访问修饰符: public,private等等,可以省略
    返回值
    包名
    类/接口名称
    方法名
    参数
    异常名: 方法定义中抛出指定异常,可以省略
可以使用通配符描述切入点,快速描述
  *: 单个代理的任意符号,可以独立出现,也可以作为前缀或者后缀的匹配符出现
    execution(public * org.example.*.UserService.find*(*))
      =>匹配org.example包下任意包中的UserService类或者接口中所有find开头的带有一个参数的方法
  ..: 多个连续的任意符号,可以独立出现,常用于简化包名与参数的书写
    execution(public User org..UserService.findById(..))
      =>匹配org包下任意包中的UserService类或者接口中所有名称为findById的方法(方法参数个数任意,可为0,也可为多个)
  +: 专用于匹配子类类型
    execution(* *..*Service+.*(..))  ->  任意业务层接口
      =>匹配 任意返回值,任意包下面的以Service结尾的类或者接口的子类,的任意方法(方法任意参数)

书写技巧
  描述切入点通常描述接口, 而不描述实现类
  访问控制修饰符针对接口开发均采用public描述(可省略访问控制修饰符描述)
  返回值类型对于增删改类使用精准类型加速匹配, 对于查询类使用*通配快速描述
  包名书写尽量不适用..匹配, 效率过低, 常用*做单个包描述匹配, 或者精准匹配
  接口名/类名书写名称与模块相关的采用*匹配, 例如UserService书写成*Service, 绑定业务层接口名
  书法名书写以动词进行精度匹配, 名词采用*匹配, 例如getById书写成getBy*, selectAll书写成selectAll
  参数规则较为复杂, 根据业务方法灵活调整
  通常不使用异常作为匹配规则



AOP通知类型
  AOP通知描述了抽取的共性功能, 过呢根据共性功能抽取的位置不同, 最终运行案底吗时要将其加入到合理的位置
  AOP通知共分为5中类型
    前置通知
      @Before("pt(){}")
      public void bofore(){System.out.println("before advice ... ");}
    后置通知  (无论方法抛不抛异常,均执行)  
      @After("pt(){}")
      public void bofore(){System.out.println("after advice ... ");}
    环绕通知
    返回后通知  (只有在方法不抛异常后执行)
      @AfterReturning("pts()")
    抛出异常后通知  (只有在方法抛异常后执行)
      @AfterThrowing("pts()")

环绕通知
  1.0 无参
    @Pointcut("execution(void org.example.dao.BookDao.update())")
    private void pt(){}
    //普通写法
    @Around("pt()")
    public void around(ProceedingJoinPoint pjp) throws Throwable{
        System.out.println("around before advice ... ");
        pjp.proceed();  //表示对原始操作的调用
        System.out.println("around after advice ... ");
    }
    //标准写法
    @Around("pt()")
    public Object around(ProceedingJoinPoint pjp) throws Throwable{
        System.out.println("around before advice ... ");
        Object ret =  pjp.proceed();  //表示对原始操作的调用
        System.out.println("around after advice ... ");
        return ret;
    }
  2.0 有参
    @Pointcut("execution(int org.example.dao.BookDao.select())")
    private void pts(){}
    @Around("pts()")
    public Object aroundSelect(ProceedingJoinPoint pjp) throws Throwable{
        System.out.println("around before advice ... ");
        Integer ret= (Integer)pjp.proceed(); 
        System.out.println("around after advice ... ");
        return ret; //可以修改返回值  =>ret+100;
    }















































