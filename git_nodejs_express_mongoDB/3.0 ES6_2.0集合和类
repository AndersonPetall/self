Set集合
  size  返回集合元素个数
  add  新增一个新元素, 返回当前集合
  delete  删除元素, 返回boolean值
  has  检测集合是否包含某个元素, 返回 boolean值
  clear  清空集合, 返回undefined
  可用for...of 遍历
声明和创建
  const set1 = new Set({1,3,5,7]);
  
...拓展运算符 自动筛掉重复的值, 并且不会发生类型转换
实例1.0 数组去重
  const a1 = ['A', 'B', 'C', 'C', 'A']
  connst s = new Set(a1);
  const result = [...s];  //A B C
实例2.0 求交集
  const a1 = [1,2,3,4,5,6,7];
  const a2 = [4,5,6,7,8,9];
  const result = [...new Set(a1)].filter(item => {
    return (new Set(a2)).had(item); });
实例3.0 求并集
  const  result = [...new Set([...new Set(a1), ...new Set(a2)])];
实例4.0 求差集
  const result = [...new Set(a1)].filter(item => {
    return !(new Set(a2)).had(item); });




Map结构  键值对
  size  返回Map元素个数
  set  新增一个新元素, 返回当前Map
  get  返回键值对的键值
  delete  删除某个键
  clear  清空集合, 返回undefined
  可用for...of 遍历
声明和创建
  const m1 = new Map();
  m1.set('mei', '小橙子');
  let key = {};  m1.set(key, 'auguigu');
  
  
  
class类
原方法:
  //创建对象的方式 new Object{} 工厂函数 构造函数 Object.create
  function Phone(brand, price){ this.brand = brand; this.price = price;}
  //添加方法
  Phone.prototype.call = function(someone) { console.log(`我可以给$(someone)大电话`);}
  //实例化对象
  const nokia = new Phone('诺基亚', 233);
class方法:
  class Phone {
    //构造   不是必须的,但是只能有一个
    constructor(brand, price){this.brand = brand; this.price = price;}
    //方法
    call(someone){ console.log(`我可以给$(someone)大电话`);}
    //静态成员与方法   被类直接调用,而不是类的实例
    static name = '手机'
    static change(){console.log('123');}
  }
  
类的继承
原方法:
    function Phone(brand, price){ this.brand = brand; this.price = price;}
    function SmartPhone(brand, price, storage, pixel){ 
      //调用父类的函数  属性的初始化
      Phone.call(this, brand, price);
      this.storage = storage; this.pixel = pixel;}
class方法:
  class Phone{
    constructor(brand, price){this.brand = brand; this.price = price;} }
  class SmartPhone{
    constructor(brand, price, storage, pixel){
      super(brand, price);
      this.storage = storage; this.pixel = pixel;} }

















  
